중간고사 없음 -> 텀프로젝트로 대체
수업시간 전에 과제 제출
교수님께서 수업시간에 과제에 질문을 하고 학생을 대답을 한다. (시간제한)
=>과제 평가

추가 질문이 필요할 경우 실습시간에 개별 질문시간을 가질 수도 있음

중간고사 이후로는 팀을 짜서 텀프로젝트 진행
=> 이전에 게임공학과 수업에서 진행했던 프로젝트에 네트워크를 집어넣는 것이 텀프로젝트

네트워크 게임 프로그래밍을 할 때 유의할 점
기존의 프로그램하고는 마인드 셋을 바꿔야함
다른 프로그래밍임

실습할 때 노트를 두고 정리하고 나서 코딩을 하자

팀플할때도 설계문서 제출 후 코딩을 시작할 수 있음

교재: TCP/IP 윈도우 소켓 프로그래밍 2판 김선우 한빛미디어 2022
리눅스 + 윈도우가 정리된 책
=> 수업에서 리눅스를 사용하지는 않을 것이지만 서버를 공부하고 싶다면 리눅스에서 해보는 것을 권장
=> 리눅스에서는 잘 짜여진 코드를 바라볼 수 있고 필요할 경우 질문도 할 수 있음

1장은 넷기초를 들었으면 알기 쉬운 내용

과제 7개 정도(5점, 10점)
과제는 성적의 40%
그냥 과제 성적이 최종 성적이 될 것임

-TCP/IP 프로토콜의 동작 원리-
	=> 상세적인 동작을 알 필요는 없지만 기본적인 지식은 있어야 이용할 수 있다.

-소켓의 기본 개념-
	=> 다양한 경로중에 최적의 경로를 탐색하는건 라우터, 우리가 신경써야하는 부분은 이동해야하는 데이터를 어떻게 분산 배치해서 실어보낼 것이냐에 집중해야함
	=> 데이터를 실어나르는 차량의 개념으로 사용할 수 있는 개념이 소켓임
	=> TCP 소켓과 UDP 소켓의 차이를 이해하고 걸맞게 잘 실어서 보내야함
	=> 서버에서는 소켓을 이해하고 데이터를 이용하게 해주면 됨
-소켓의 역사와 특징-
	=> 별 이야기 아님

-소켓 프로그램을 작성하고 실행하는 과정-
	=> 배운게 없어서 예제 프로그램이 주어질 것, 따라해보는 과정, 과정을 익혀보면 됨



-TCP/IP 프로트콜 개요-
후스트가 소켓에 데이터를 실어 라우터에 보내면 라우터는 목적지 주소를 보고 목적지 주소에 가장 가까운 라우터로 데이터를 보냄, 또 그 라우터는 IP 주소를 보고 목적지로 데이터를 보냄

인터넷의 핵심 프로토콜

네트워크 접근 계층
=> 물리적 네트워크를 통한 데이터 송수신, 네트워크 하드웨어와 장치 드라이버로 구성, 맥어드레스
이더넷 카드 - RJ45

인터넷 계층
=> 네트워크 접근 계층의 도움을 받아 데이터를 호스트 까지 전달, IP 주소와 라우팅(라우터)으로 구성


전송 계층
=> 최종 통신 목적지를 지정하고 오류 없이 데이터를 전송, 포트 번호로 주소를 지정, TCP/UDP 가 대표적

포트 번호를 통해 최종 목적지(어플리케이션)을 인식


TCP와 UDP
처음에는 TCP 관련 과제/예제를 살펴볼 것임
TCP: 연결형 프로토콜
UDP: 비연결형 프로토콜 

비연결형이라고 연결이 안되어있는게 아님

TCP는 연결 설정을 먼저함(전화 통화), UDP는 연결 설정 과정이 없음(문자 메세지)
TCP는 신뢰성 있는 데이터를 전송, 수신자에게 데이터가 잘 받을 때까지 데이터를 재전송함, 받는 쪽에서 데이터가 제대로 왔는지 검수를 안하는 거시 아니라 UDP는 데이터가 제대로 왔는지 검수하고 문제가 있으면 폐기하고 재전송 요청을 하지 않음
TCP보다 UDP가 빠르고 (부가정보)데이터가 작음
동영상과 같은 데이터를 전송할 때는 신뢰보다는 속도가 중요해 UDP를 사용할 수 있음
TCP는 멀티클라이언트를 처리할 때 멀티스레드를 구현해야함, UDP는 멀티클라이언트를 처리할 때 멀티스레드를 구현할 필요없음
TCP는 데이터 경계 구분을 안하고 UDP는 데이터 경계를 구분함

응용계층
전송계층 위에 있는 응용프로그램을 작성하는 계층

패킷이란?
데이터 앞 뒤에 송수신을 위한 제어정보를 붙인 데이터

==소켓==
데이터를 이동시키려고 미리 만들어 놓은 틀

데이터 타입 관점으로 본 소켓
=> 파일 디스크립터와 유사한 개념

통신 종단점으로 본 소켓
=> 소켓이 상대편 소켓과 연결된것으로 생각하고 데이터를 주고 받음

네트워크 프로그래밍 인터페이스
=> 응용계층과 전송계층 그 사이로 생각할 수 있음

윈도우 소켓/유닉스 소켓

소켓이 돌아가는 운영체제의 차이로 발생한 두 소켓의 차이
=> 윈도우 소켓은 DLL 초기화와 종료 작업을 위한 함수가 필요, GUI를 갖추고 메세지 구동 방식으로 동작하므로 이를 위한 확장 함수가 존재, 윈도우는 운영체제 차원에서 멀티스레드를 지원해서 멀티스레드 환경에서 안정적으로 동작하는 구조와 이를 위한 함수가 필요

-윈도우 소켓의 장점-
유닉스 소켓과 호환성이 높다 => 윈도우 소켓 공부를 하면 유닉스 환경에서 공부를 적게해도 충분히 구현가능
많이 사용되서 활용의 예가 많다 => 초기에는 안정성이 떨어짐 + 가격이 비쌈, 현재는 안정화
TCP/IP외의 프로토콜도 지원한다.
비교적 저수준 프로그래밍 인터페이스라 세부 제어가 가능하다 => 유닉스가 더 세부제어가 가능함(유닉스는 소스 공개를 함)

-윈도우 소켓의 단점-
윈도우는 바이트 정렬 방식이 달라서 데이터 처리 단위가 다른 호스트 끼리 통신할 때 응용 프로그램 수준에서 데이터 변환을 처리해야함


-2장 소켓 시작하기-
윈도우 소켓과 다이나믹 업로드 라이브러리를 메모리에 올리기 위해 소켓을 초기화

1. 오류처리
오류 처리의 유형
- 오류를 처리할 필요가 없는 경우: 리턴값이 없거나 호출시 항상 성공하는 일부 소켓 함수
- 리턴값만으로 오류를 처리하는 경우: WSAStartUP() 함수(윈도우소켓 초기화함수)
- 리턴값으로 오류 발생을 확인하고, 구체적인 내용은 오류 코드로 확인하는 경우: 대부분의 소켓함수

WSAGetLastError() - 마지막에 발생한 오류를 리턴해주는 함수
FormatMessage() - 오류 코드를 문자열로 바꾸기 위한 함수
FORMAT_MESSAGE_ALLOCATE_BUFFER - 시스템(운영체제)에게 오류 메세지 만큼의 버퍼를 할당시키게 함
FORMAT_MESSAGE_FROM_SYSTEM - 시스템(운영체제)에게 오류 메세지를 가져오게 함
MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT) - 메세지의 언어를 윈도우 시스템의 기본언어로 설정

2. 윈속(윈도우 소켓) 초기화와 종료
윈속 초기화(바이너리 링크드 라이브러리를 메모리에 올리기 위해) -> 소켓 생성 -> 통신 ->소켓 닫기 -> 윈속 종료

WSAStartup() - 윈속을 초기화하는 함수(첫번째 인자는 버전, 두번째 인자는 윈속 초기화와 관련된 부속 정보를 넣어줌)
WORD는 2바이트 자료형, MAKEWORD(2, 2)와 같은 형태로 생성
WSACleanup() - 윈속을 종료하는 함수(성공시 0, 실패시 SOCKET_ERROR) 리턴
socket() - 소켓을 생성하는 함수, 주소 체계/소켓 타입/프로토콜을 전달 받아 소켓을 생성, 소켓 디스크립터를 리턴

-주소 체계-
AF_INET // IPv4, 인터넷: UDP, TCP
AF_INET6 // IPv6
AF_BTH // 블루투스

-소켓 타입-
SOCK_STREAM // TCP
SOCK_DGRAM // UDP

-프로토콜-
IPPROTO_TCP // TCP
IPPROTO_UDP // UDP
0 // 알아서 지정

closesocket() 소켓을 닫는 함수, 성공시 0을 리턴하고 실패시 SOCKET_ERROR를 리턴

///------------
WSDATA 자료형을 가지는 wsa 변수는 윈속 초기화와 관련된 부속정보를 가집니다. wVersion은 WORD형 데이터로 사용자가 초기화한 윈속의 버전 정보가 상위 8개 bit에는 부 버전 정보가, 하위 8개 bit 주 버전 정보가 담겨있습니다. 따라서 wVersion을 출력하기 위해서는 상위 8개 bit와 하위 8개 bit를 따로 출력해주어야합니다. 저는 LOBYTE()를 사용해 하위 8개 bit를, HIBYTE()를 사용해 상위 8개 bit를 가져와서 출력을 해주었습니다.


































